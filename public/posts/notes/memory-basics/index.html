<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Memory Basics | HyperBlog</title>
<meta name="keywords" content="CTFs, tech">
<meta name="description" content="Memory is essential to understand for pwning in CTFs. Here, I will try to explain the structure of memory and behaviors for beginners in pwn.
Definition of Memory First, a basic definition of memory. Have you ever seen that long card in your computer with black squares on it? That&rsquo;s memory. Most people (who watch Linus Tech Tips) know this as Random Access Memory (RAM), but at the core it is just temporary storage on your computer.">
<meta name="author" content="John Wu">
<link rel="canonical" href="https://blog.hyperboly.net/posts/notes/memory-basics/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css" integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://blog.hyperboly.net/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.hyperboly.net/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.hyperboly.net/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.hyperboly.net/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.hyperboly.net/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Memory Basics" />
<meta property="og:description" content="Memory is essential to understand for pwning in CTFs. Here, I will try to explain the structure of memory and behaviors for beginners in pwn.
Definition of Memory First, a basic definition of memory. Have you ever seen that long card in your computer with black squares on it? That&rsquo;s memory. Most people (who watch Linus Tech Tips) know this as Random Access Memory (RAM), but at the core it is just temporary storage on your computer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.hyperboly.net/posts/notes/memory-basics/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-19T20:08:56&#43;08:00" />
<meta property="article:modified_time" content="2023-03-19T20:08:56&#43;08:00" /><meta property="og:site_name" content="HyperBlog" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Memory Basics"/>
<meta name="twitter:description" content="Memory is essential to understand for pwning in CTFs. Here, I will try to explain the structure of memory and behaviors for beginners in pwn.
Definition of Memory First, a basic definition of memory. Have you ever seen that long card in your computer with black squares on it? That&rsquo;s memory. Most people (who watch Linus Tech Tips) know this as Random Access Memory (RAM), but at the core it is just temporary storage on your computer."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.hyperboly.net/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Memory Basics",
      "item": "https://blog.hyperboly.net/posts/notes/memory-basics/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Memory Basics",
  "name": "Memory Basics",
  "description": "Memory is essential to understand for pwning in CTFs. Here, I will try to explain the structure of memory and behaviors for beginners in pwn.\nDefinition of Memory First, a basic definition of memory. Have you ever seen that long card in your computer with black squares on it? That\u0026rsquo;s memory. Most people (who watch Linus Tech Tips) know this as Random Access Memory (RAM), but at the core it is just temporary storage on your computer.",
  "keywords": [
    "CTFs", "tech"
  ],
  "articleBody": "Memory is essential to understand for pwning in CTFs. Here, I will try to explain the structure of memory and behaviors for beginners in pwn.\nDefinition of Memory First, a basic definition of memory. Have you ever seen that long card in your computer with black squares on it? That’s memory. Most people (who watch Linus Tech Tips) know this as Random Access Memory (RAM), but at the core it is just temporary storage on your computer. Memory Structure I will abstract a lot of the memory structure here, so read on knowing there will be inaccuracies. Think of memory as a building, each floor is a storage space, and a building only has so many floors. Each floor and groups of floors can have a different purpose, the basement is for parking, floor 1 is for the lobby, floor 2 is for a restaurant, and the rest are residential. Now think of the floors as space in memory. There are 3 main spaces in memory, the data, stack, and heap.\nDiagram of Memory    Memory Space Description     Data Is where “static” variables are   Stack Is where “local” variables are   Heap Is where “buffers” exist    The Data Memory Space The data space will not be used in many beginner pwn questions, I don’t think I’ve ever encountered it. It also means that they don’t get deleted once a function is finished, these variables persist until the program dies. This means that nothing in the data space should change while the program is running. This would include things from libraries, a variable named MAX_HEIGHT, and others like that.\nThe Stack Memory Space This is the part of memory that many beginner pwn questions will want you to attack. If you’ve ever went on stackoverflow.com, the stack in memory is where that name came from. “Stack overflow” attacks are a common way that CTFs question beginners. The stack is where variable in a function exists. This would include the main function. Stacks contains variables that the programmer defines the memory to. For example, int foo = 7; is the programmer dedicating 4 bytes of memory to foo. He is dedicating 4 bytes because by default in C, an integer is 4 bytes in length. Inside the 4 bytes, it would only store “7” though.\nProbably more important than variables in the stack is the pointer and addresses in the stack. The stack pointer is not like pointers in C/C++. The stack pointer indicates where the program is while the program is running. This becomes very helpful while debugging. The Extended Instruction Pointer exists at the end of the stack execution, where it will look for the next instruction. This becomes useful when we do something called a “stack overflow,” where you overflow the whole stack and enter in the malicious instruction onto the original instruction pointer space. Later articles will further explain the stack.\nThe stack does NOT include the buffers, which is in the “heap.”\nThe Heap Memory Space The heap is, as mentioned, where the buffers live. But what are buffers? Buffers are spaces in code that the programmer dictates. How is this different from declaring a variable in the stack? Stack variables can’t be resized, but buffers can. If I create a array in C, like this: int ary[100], I am dynamically assigning 100 bytes to ary. Confused? Me too! Stack variables have the life cycle of being declared, stored, and initialized during runtime. When the function ends, so do the variables in the stack.\nThe heap is more “floaty,” as in it exists in no particular order. Multiple buffers can live in memory without an order like stack variables do. The memory allocated is also decided by the programmer, not the compiler. Before I mentioned int takes 4 bytes of space, this is not a decision by the programmer but by the compiler. Compared to int ary[100], the programmer specifies that he wants 100 bytes for this.\n",
  "wordCount" : "658",
  "inLanguage": "en",
  "datePublished": "2023-03-19T20:08:56+08:00",
  "dateModified": "2023-03-19T20:08:56+08:00",
  "author":{
    "@type": "Person",
    "name": "John Wu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.hyperboly.net/posts/notes/memory-basics/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "HyperBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.hyperboly.net/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.hyperboly.net/" accesskey="h" title="HyperBlog (Alt + H)">HyperBlog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.hyperboly.net/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://blog.hyperboly.net/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.hyperboly.net/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Memory Basics
    </h1>
    <div class="post-meta"><span title='2023-03-19 20:08:56 +0800 CST'>March 19, 2023</span>&nbsp;·&nbsp;John Wu

</div>
  </header> 
  <div class="post-content"><p>Memory is essential to understand for pwning in CTFs. Here, I will try to explain the structure of memory and behaviors for beginners in pwn.</p>
<h2 id="definition-of-memory">Definition of Memory<a hidden class="anchor" aria-hidden="true" href="#definition-of-memory">#</a></h2>
<p>First, a basic definition of memory. Have you ever seen that long card in your computer with black squares on it? That&rsquo;s memory. Most people (who watch Linus Tech Tips) know this as Random Access Memory (RAM), but at the core it is just temporary storage on your computer.
<img loading="lazy" src="/RAM-stick.jpg" alt="RAM Stick"  />
</p>
<h2 id="memory-structure">Memory Structure<a hidden class="anchor" aria-hidden="true" href="#memory-structure">#</a></h2>
<p>I will abstract a lot of the memory structure here, so read on knowing there will be inaccuracies. Think of memory as a building, each floor is a storage space, and a building only has so many floors. Each floor and groups of floors can have a different purpose, the basement is for parking, floor 1 is for the lobby, floor 2 is for a restaurant, and the rest are residential. Now think of the floors as space in memory. There are 3 main spaces in memory, the data, stack, and heap.</p>
<h3 id="diagram-of-memory">Diagram of Memory<a hidden class="anchor" aria-hidden="true" href="#diagram-of-memory">#</a></h3>
<table>
<thead>
<tr>
<th>Memory Space</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data</td>
<td>Is where &ldquo;static&rdquo; variables are</td>
</tr>
<tr>
<td>Stack</td>
<td>Is where &ldquo;local&rdquo; variables are</td>
</tr>
<tr>
<td>Heap</td>
<td>Is where &ldquo;buffers&rdquo; exist</td>
</tr>
</tbody>
</table>
<h4 id="the-data-memory-space">The Data Memory Space<a hidden class="anchor" aria-hidden="true" href="#the-data-memory-space">#</a></h4>
<p>The data space will not be used in many beginner pwn questions, I don&rsquo;t think I&rsquo;ve ever encountered it. It also means that they don&rsquo;t get deleted once a function is finished, these variables persist until the program dies. This means that nothing in the data space should change while the program is running. This would include things from libraries, a variable named MAX_HEIGHT, and others like that.</p>
<h4 id="the-stack-memory-space">The Stack Memory Space<a hidden class="anchor" aria-hidden="true" href="#the-stack-memory-space">#</a></h4>
<p>This is the part of memory that many beginner pwn questions will want you to attack. If you&rsquo;ve ever went on stackoverflow.com, the stack in memory is where that name came from. &ldquo;Stack overflow&rdquo; attacks are a common way that CTFs question beginners. The stack is where variable in a function exists. This would include the <code>main</code> function. Stacks contains variables that the programmer defines the memory to. For example, <code>int foo = 7;</code> is the programmer dedicating 4 bytes of memory to <code>foo</code>. He is dedicating 4 bytes because by default in C, an integer is 4 bytes in length. Inside the 4 bytes, it would only store &ldquo;7&rdquo; though.</p>
<p>Probably more important than variables in the stack is the pointer and addresses in the stack. The stack pointer is not like pointers in C/C++. The stack pointer indicates where the program is while the program is running. This becomes very helpful while debugging. The Extended Instruction Pointer exists at the end of the stack execution, where it will look for the next instruction. This becomes useful when we do something called a &ldquo;stack overflow,&rdquo; where you overflow the whole stack and enter in the malicious instruction onto the original instruction pointer space. Later articles will further explain the stack.</p>
<p>The stack does NOT include the buffers, which is in the &ldquo;heap.&rdquo;</p>
<h4 id="the-heap-memory-space">The Heap Memory Space<a hidden class="anchor" aria-hidden="true" href="#the-heap-memory-space">#</a></h4>
<p>The heap is, as mentioned, where the buffers live. But what are buffers? Buffers are spaces in code that the programmer dictates. How is this different from declaring a variable in the stack? Stack variables can&rsquo;t be resized, but buffers can. If I create a array in C, like this: <code>int ary[100]</code>, I am dynamically assigning 100 bytes to <code>ary</code>. Confused? Me too! Stack variables have the life cycle of being declared, stored, and initialized during <strong>runtime</strong>. When the function ends, so do the variables in the stack.</p>
<p>The heap is more &ldquo;floaty,&rdquo; as in it exists in no particular order. Multiple buffers can live in memory without an order like stack variables do. The memory allocated is also decided by the programmer, not the compiler. Before I mentioned <code>int</code> takes 4 bytes of space, this is not a decision by the programmer but by the compiler. Compared to <code>int ary[100]</code>, the programmer specifies that he wants 100 bytes for this.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.hyperboly.net/tags/ctfs/">CTFs</a></li>
      <li><a href="https://blog.hyperboly.net/tags/tech/">tech</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://blog.hyperboly.net/">HyperBlog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
